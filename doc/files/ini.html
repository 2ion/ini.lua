<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <title>Luadocs for ini.lua</title>
    <link rel="stylesheet" href="../luadoc.css" type="text/css" />
    <!--meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/-->
</head>

<body>
<div id="container">

<div id="product">
    <div id="product_logo"></div>
    <div id="product_name"><big><b></b></big></div>
    <div id="product_description"></div>
</div> <!-- id="product" -->

<div id="main">

<div id="navigation">


<h1>LuaDoc</h1>
<ul>
	
	<li><a href="../index.html">Index</a></li>
	
</ul>


<!-- Module list -->



<!-- File list -->

<h1>Files</h1>
<ul>

	<li><strong>ini.lua</strong></li>
	
</ul>






</div> <!-- id="navigation" -->

<div id="content">

<h1>File <code>ini.lua</code></h1>







<h2>Functions</h2>
<table class="function_list">

    <tr>
    <td class="name" nowrap><a href="#base64_decode">base64_decode</a>&nbsp;(b64str)</td>
    <td class="summary">Decode a string holding base64 encoded data to a Lua string.</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#base64_encode">base64_encode</a>&nbsp;(str)</td>
    <td class="summary">Encode the data in str to base64.</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#debug_enum">debug_enum</a>&nbsp;(t, section)</td>
    <td class="summary">Print out the kv-pairs of a Lua table, with a prefix per line.</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#read">read</a>&nbsp;(file)</td>
    <td class="summary">Parse a flat INI file and map the data to a Lua table.</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#read64">read64</a>&nbsp;(file)</td>
    <td class="summary">Like read(), but treat values starting with the sequence `base64:` as special: the base64 encoded data will be decoded into a string value and may hold arbitrary binary data.</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#read_nested">read_nested</a>&nbsp;(file)</td>
    <td class="summary">Like read(), but reads only nested INI files.</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#write">write</a>&nbsp;(file, data)</td>
    <td class="summary">Writes a Lua table as a flat INI file to a file.</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#write64">write64</a>&nbsp;(file, data)</td>
    <td class="summary">Like write(), but treats values with a metatable which has the key __ini_is_binary set to a TRUE value specially.</td>
    </tr>

    <tr>
    <td class="name" nowrap><a href="#write_nested">write_nested</a>&nbsp;(file, data)</td>
    <td class="summary">Like write(), but can write a nested INI data structure.</td>
    </tr>

</table>






<br/>
<br/>




<h2><a name="functions"></a>Functions</h2>
<dl class="function">



<dt><a name="base64_decode"></a><strong>base64_decode</strong>&nbsp;(b64str)</dt>
<dd>
Decode a string holding base64 encoded data to a Lua string. The resulting string may hold arbitrary binary data.


<h3>Parameters</h3>
<ul>
	
	<li>
	  b64str: Lua string, base64 encoded data
	</li>
	
</ul>






<h3>Return value:</h3>
Lua string with the deoded data, conversion byte count



<h3>See also:</h3>
<ul>
	
	<li><a href="">
		base64_encode()
	</a>
	
</ul>

</dd>




<dt><a name="base64_encode"></a><strong>base64_encode</strong>&nbsp;(str)</dt>
<dd>
Encode the data in str to base64.


<h3>Parameters</h3>
<ul>
	
	<li>
	  str: input string, can hold arbitrary binary data
	</li>
	
</ul>






<h3>Return value:</h3>
Lua string with the base64 representation, base64 byte count



<h3>See also:</h3>
<ul>
	
	<li><a href="">
		base64_decode()
	</a>
	
</ul>

</dd>




<dt><a name="debug_enum"></a><strong>debug_enum</strong>&nbsp;(t, section)</dt>
<dd>
Print out the kv-pairs of a Lua table, with a prefix per line. Use to enumerate the contents of a INI data table.


<h3>Parameters</h3>
<ul>
	
	<li>
	  t: INI data table
	</li>
	
	<li>
	  section: line prefix, may be empty
	</li>
	
</ul>






<h3>Return value:</h3>
Nothing



</dd>




<dt><a name="read"></a><strong>read</strong>&nbsp;(file)</dt>
<dd>
Parse a flat INI file and map the data to a Lua table. The resulting kv-pairs will always be pairs of strings.


<h3>Parameters</h3>
<ul>
	
	<li>
	  file: the file to read the data from
	</li>
	
</ul>






<h3>Return value:</h3>
NIL in case of an error (file does not exist or is not readable). In case of success: data table, table with invalid lines in the source file.



</dd>




<dt><a name="read64"></a><strong>read64</strong>&nbsp;(file)</dt>
<dd>
Like read(), but treat values starting with the sequence `base64:` as special: the base64 encoded data will be decoded into a string value and may hold arbitrary binary data. Standard Lua string functions may not work reliably on these strings. Binary values will have a metatable with the key `__ini_is_binary` set to a TRUE value.


<h3>Parameters</h3>
<ul>
	
	<li>
	  file: source file
	</li>
	
</ul>






<h3>Return value:</h3>
in case of an error: NIL. Otherwise: data table, table with lines rejected by the parser.



<h3>See also:</h3>
<ul>
	
	<li><a href="../files/ini.html#read">
		read
	</a>
	
</ul>

</dd>




<dt><a name="read_nested"></a><strong>read_nested</strong>&nbsp;(file)</dt>
<dd>
Like read(), but reads only nested INI files. There is no autodetection of the nesting, so be careful.


<h3>Parameters</h3>
<ul>
	
	<li>
	  file: input file
	</li>
	
</ul>






<h3>Return value:</h3>
In case of an error. Otherwise: data table, table with rejected lines



<h3>See also:</h3>
<ul>
	
	<li><a href="">
		read()
	</a>
	
</ul>

</dd>




<dt><a name="write"></a><strong>write</strong>&nbsp;(file, data)</dt>
<dd>
Writes a Lua table as a flat INI file to a file. Sections cannot be nested.


<h3>Parameters</h3>
<ul>
	
	<li>
	  file: output file
	</li>
	
	<li>
	  data: data table. Format: { <SectionA> = { key = value[, ...] }, <SectionN>= { [...] } }
	</li>
	
</ul>






<h3>Return value:</h3>
In case of an error (could not open file, no input data): NIL. Else: true



<h3>See also:</h3>
<ul>
	
	<li><a href="">
		read()
	</a>
	
</ul>

</dd>




<dt><a name="write64"></a><strong>write64</strong>&nbsp;(file, data)</dt>
<dd>
Like write(), but treats values with a metatable which has the key __ini_is_binary set to a TRUE value specially. These values will be encoded to base64 before being written out, allowing arbitrary binary data to be written. The data may be retrieved using only read64().


<h3>Parameters</h3>
<ul>
	
	<li>
	  file: output file
	</li>
	
	<li>
	  data: data table
	</li>
	
</ul>






<h3>Return value:</h3>
NIL (could not open file or no data), otherwise: true



</dd>




<dt><a name="write_nested"></a><strong>write_nested</strong>&nbsp;(file, data)</dt>
<dd>
Like write(), but can write a nested INI data structure.


<h3>Parameters</h3>
<ul>
	
	<li>
	  file: output file
	</li>
	
	<li>
	  data: like in write(), but allowing nested sections: { A = { B -- = { k = v }, k = v }, B = { [...] } }
	</li>
	
</ul>






<h3>Return value:</h3>
NIL in case of an error, otherwise: TRUE



</dd>


</dl>







</div> <!-- id="content" -->

</div> <!-- id="main" -->

<div id="about">
    <p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0!" height="31" width="88" /></a></p>
</div> <!-- id="about" -->

</div> <!-- id="container" -->
</body>
</html>
